# python

# This script exports selected line features from the active QGIS layer
# to a SQL file that can be used to insert them into the 'infrastructure_link'
# table in a PostGIS database. It calculates the ellipsoidal length of each
# feature using the GRS80 ellipsoid and transforms geometries to EPSG:4326
# for storage as geography(LineStringZ,4326).
#
# Configuration options at the top of the script allow customization of
# the output file path, table name, direction, external link source,
# ID field, and batch size for inserts.
#
# Open the script in the QGIS Python console and run it with an active layer
# containing selected (with one of the selection tools) line features to
# generate the SQL file. If no features are selected, the entire layer will
# be exported.


from qgis.core import (
    QgsProject,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
    QgsDistanceArea,
)
from qgis.utils import iface

import uuid

# Config
output_path = '/tmp/tram_infraLinks.sql'
table_name = 'infrastructure_network.infrastructure_link'
direction = 'bidirectional'
external_link_source = 'temp_hsl_tram'
id_field = 'mtk_id'
batch_size = 50

layer = iface.activeLayer()
if layer is None:
    raise RuntimeError('No active layer.')

proj = QgsProject.instance()
src_crs = layer.crs()
dst_crs = QgsCoordinateReferenceSystem('EPSG:4326')
transform = QgsCoordinateTransform(src_crs, dst_crs, proj)

# Ellipsoidal length calculator on GRS80 (EPSG:7019)
dist = QgsDistanceArea()
dist.setSourceCrs(src_crs, proj.transformContext())
ok = False
try:
    ok = dist.setEllipsoid('EPSG:7019')
except Exception:
    ok = False
if not ok:
    dist.setEllipsoid('GRS80')  # fallback

def sql_quote(val):
    if val is None:
        return 'NULL'
    return "'" + str(val).replace("'", "''") + "'"

# Determine feature source: selected or full layer
selected_count = layer.selectedFeatureCount()
if selected_count > 0:
  features = list(layer.selectedFeatures())
  export_count = selected_count
else:
  print("No features selected; exporting entire layer.")
  features = list(layer.getFeatures())
  export_count = layer.featureCount()

lines = []
lines.append('-- SQL export generated by QGIS Python console')
lines.append(f'-- Source layer: {layer.name()}')
lines.append(f'-- Exported features (source): {export_count}')
lines.append('BEGIN;')

# Add infralink type
lines.append("""
-- Create schema and tables if they don't exist. Needed in digiroad-import repo when generating mbtiles.
CREATE SCHEMA IF NOT EXISTS infrastructure_network;

CREATE TABLE IF NOT EXISTS infrastructure_network.external_source (
  value text NOT NULL
);

CREATE TABLE infrastructure_network.vehicle_submode_on_infrastructure_link (
    infrastructure_link_id uuid NOT NULL,
    vehicle_submode text NOT NULL
);

CREATE TABLE IF NOT EXISTS infrastructure_network.infrastructure_link (
    infrastructure_link_id uuid DEFAULT public.gen_random_uuid() NOT NULL,
    direction text NOT NULL,
    shape public.geography(LineStringZ,4326) NOT NULL,
    estimated_length_in_metres double precision,
    external_link_id text NOT NULL,
    external_link_source text NOT NULL
);

-- Add the temporary link external source type is it doesn't exist
INSERT INTO infrastructure_network.external_source VALUES ('temp_hsl_tram') ON CONFLICT DO NOTHING;

""")


batch_values = []

# Diagnostics
written = 0            # rows added to VALUES
seen = 0               # features iterated
failed_transform = 0
skipped_empty = 0
skipped_non_line = 0
non_tram = 0

def flush_batch():
    if not batch_values:
        return
    values_sql = ',\n  '.join(batch_values)
    insert_sql = (
        f"INSERT INTO {table_name} "
        "(infrastructure_link_id, direction, shape, estimated_length_in_metres, external_link_id, external_link_source)\n"
        f"VALUES\n  {values_sql};"
    )
    lines.append(insert_sql)
    batch_values.clear()

field_names = layer.fields().names()

for f in features:
    if f['kohdeluokka'] not in (14141, 14142):
        non_tram += 1
        continue

    seen += 1
    geom = f.geometry()
    if geom is None or geom.isEmpty():
        skipped_empty += 1
        continue

    # 1) Ellipsoidal length in metres
    try:
        length_m = dist.measureLength(geom)
    except Exception:
        length_m = None

    # 2) Try to merge multipart lines to single, if any
    try:
        merged = geom.lineMerge()
        if merged and not merged.isEmpty():
            geom = merged
    except Exception:
        pass

    # 3) Transform geometry to EPSG:4326 for WKT Z output
    try:
        geom.transform(transform)
    except Exception:
        failed_transform += 1
        continue

    wkt = geom.asWkt()  # LINESTRING Z (...) expected
    up = wkt.upper()
    if not up.startswith('LINESTRING'):
        # Skip non-lines if target column is geography(LineStringZ,4326)
        skipped_non_line += 1
        continue

    external_id = f[id_field] if id_field in field_names else None
    length_sql = 'NULL' if length_m is None else f"{float(length_m)}"
    ext_id_sql = sql_quote(external_id)

    infrastructure_link_id = str(uuid.uuid4())

    # geography from EWKT in 4326 with Z
    shape_sql = (
        f"CAST(ST_GeogFromText('SRID=4326;{wkt}') AS geography(LineStringZ,4326))"
    )

    value_sql = (
        f"('{infrastructure_link_id}', '{direction}', {shape_sql}, {length_sql}, {ext_id_sql}, '{external_link_source}')"
    )
    batch_values.append(value_sql)
    written += 1

    if len(batch_values) >= batch_size:
        flush_batch()

flush_batch()


lines.append("""
-- Select all infralink ids from 'infrastructure_link' table and insert them to the 'vehicle_submode_on_infrastructure_link' table
-- along with static 'generic_tram' vehicle submode info

INSERT INTO infrastructure_network.vehicle_submode_on_infrastructure_link
  SELECT il.infrastructure_link_id,
         'generic_tram' AS vehicle_submode
  FROM infrastructure_network.infrastructure_link il
  WHERE il.external_link_source = 'temp_hsl_tram'
ON CONFLICT DO NOTHING;


COMMIT;
""")

with open(output_path, 'w', encoding='utf-8') as fh:
    fh.write('\n'.join(lines))

print(f"Wrote SQL to {output_path} with {written} value rows from {seen} features; skipped non_tram: {non_tram}, skipped empty: {skipped_empty}, failed_transform: {failed_transform}, non-line: {skipped_non_line}.")
